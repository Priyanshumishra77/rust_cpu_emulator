// ARM Assembly Pest Grammar

whitespace = _{ " " | "\t" }
newline = _{ "\n" }
comma = _{ "," }

comment = _{ "@" ~ (!newline ~ ANY)* }


alpha = { 'a'..'z' | 'A'..'Z' }
digit = { '0'..'9' }

register = { (^"r" ~ digit+ | ^"sp" | ^"lr" | ^"pc" | ^"fp") }
label_name = { ( alpha| "_") ~ (alpha | digit | "_")* }

variable_name = { ( alpha| "_") ~ (alpha | digit | "_")* }
integer = { digit+ }

file = _{ SOI ~ assembly ~ EOI }

assembly = _{ ( preamble | section) ~ (newline ~ section)* }
preamble = _ {directive_line ~ ( newline ~ directive_line)* }
section = _{(data_section | text_section)}

empty_line = {whitespace* ~ comment?}

// Directive
directive_name = { !".section" ~ "." ~ alpha+ }
directive_line = { whitespace* ~  directive_name ~ whitespace* ~ (label_name | integer)? ~ whitespace* ~ comment? }

// Data
data_section = _{^".section" ~whitespace+ ~ ^".data" ~ whitespace* ~ comment? ~ (newline ~ (data_line | directive_line ))* }
data_line = { whitespace* ~ variable_name ~ ":" ~ whitespace+ ~ ^".word" ~ whitespace+ ~ integer ~ whitespace* ~ comment?}

text_section = _{^".section" ~whitespace+ ~ ^".text" ~ whitespace* ~ comment? ~ (newline ~ (text_line | directive_line))* }
text_line = _{whitespace* ~ (instr | label) ~ whitespace* ~ comment? }

label = { label_name ~ ":" }

// Define the single instr rule
instr = { mnemonic ~ (whitespace+ ~ operand ~ (operand_sep ~ operand)*)? }
mnemonic = { alpha+ }  // Matches the instruction name

immediate = { "#" ~ integer }
memory_access = { "[" ~ register ~ ("," ~ whitespace* ~ (register | immediate) ~ whitespace*)? ~ "]" }
variable_address = { "=" ~ label_name }
operand_sep = _{ whitespace* ~ comma ~ whitespace* }
operand = _{ register | immediate | memory_access | variable_address | label_name }
