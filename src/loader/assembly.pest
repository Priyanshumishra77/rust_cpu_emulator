// ARM Assembly Pest Grammar

whitespace = _{ " " | "\t" }
newline = _{ "\n" }
comma = _{ "," }
arg_sep = _{ whitespace* ~ comma ~ whitespace* }
comment = _{ "@" ~ (!newline ~ ANY)* }
empty_line = _{ newline ~ whitespace* ~ comment? }

alpha = { 'a'..'z' | 'A'..'Z' }
digit = { '0'..'9' }

register = { (^"r" ~ digit+ | ^"sp" | ^"lr" | ^"pc" | ^"fp") }
label_name = { (alpha | digit | "_")+ }

// todo: we should not need variable name since it is just a label
variable_name = { ( alpha| "_") ~ (alpha | digit | "_")* }
integer = { digit+ }
immediate = { "#" ~ integer }
variable_address = { "=" ~ label_name }

memory_access = { "[" ~ register ~ ("," ~ whitespace* ~ (register | immediate) ~ whitespace*)? ~ "]" }

file = _{ SOI ~ assembly ~ EOI }
assembly = _{ ( directive_line | data_line| text_line )* }

// Directive
directive_line = _{ newline ~ whitespace* ~ directive ~ whitespace* ~ comment? }
directive_name = { "." ~ alpha+ }
directive = { directive_name ~ whitespace* ~ (label_name | integer)?  }

// Data
data_line = _{ newline ~ whitespace* ~ data ~ whitespace* ~ comment? }
// todo: variable name should be label name
data = { variable_name ~ ":" ~ whitespace+ ~ ".word" ~ whitespace+ ~ integer }



text_line = { newline ~ whitespace* ~ (instr | label) ~ whitespace* ~ comment? }

label = { label_name ~ ":" }

// Define the single instr rule
instr = { mnemonic ~ whitespace+ ~ operand_list }
mnemonic = { alpha+ }  // Matches the instruction name
operand_list = { operand ~ (arg_sep ~ operand)* }
operand = { register | immediate | memory_access | variable_address | label_name }
