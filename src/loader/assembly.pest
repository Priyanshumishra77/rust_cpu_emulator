// ARM Assembly Pest Grammar

whitespace = _{ " " | "\t" }
newline = _{ "\n" }
comma = _{ "," }
arg_sep = _{ whitespace* ~ comma ~ whitespace* }
comment = _{ "@" ~ (!newline ~ ANY)* }


alpha = { 'a'..'z' | 'A'..'Z' }
digit = { '0'..'9' }

register = { (^"r" ~ digit+ | ^"sp" | ^"lr" | ^"pc" | ^"fp") }
label_name = { ( alpha| "_") ~ (alpha | digit | "_")* }

variable_name = { ( alpha| "_") ~ (alpha | digit | "_")* }
integer = { digit+ }



file = _{ SOI ~ assembly ~ EOI }
assembly = _{ assembly_line ~ (newline ~ assembly_line )* }

assembly_line = _{ (directive_line | data_line | text_line | empty_line )}

empty_line = {whitespace* ~ comment?}

// Directive
directive_name = { "." ~ alpha+ }
directive_line = { whitespace* ~  directive_name ~ whitespace* ~ (label_name | integer)? ~ whitespace* ~ comment? }

// Data
data_line = { whitespace* ~ variable_name ~ ":" ~ whitespace+ ~ ".word" ~ whitespace+ ~ integer ~ whitespace* ~ comment?}

text_line = {whitespace* ~ (instr | label)~ whitespace* ~ comment? }

label = { label_name ~ ":" }

// Define the single instr rule
instr = { mnemonic ~ whitespace+ ~ operand_list }
mnemonic = { alpha+ }  // Matches the instruction name
operand_list = { operand ~ (arg_sep ~ operand)* }

immediate = { "#" ~ integer }
memory_access = { "[" ~ register ~ ("," ~ whitespace* ~ (register | immediate) ~ whitespace*)? ~ "]" }
variable_address = { "=" ~ label_name }
operand = { register | immediate | memory_access | variable_address | label_name }
