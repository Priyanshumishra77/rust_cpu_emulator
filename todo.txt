TODO

- There is a problem with the reuse of the physical register.
    without reuse, the chain of independent incs works fine, but with
    reuse, a later inc gets a value from an reused physical register.

    The following seems very weird because when issuing an INC, the same physical register is used
    For the source and then for the sink. Since it can be read from, physical register should
    Not have been deallocated. So it is possible to retire a physical register, even though the
    mapping in the RAT is valid and points to that physical register.

        issue: Issue INC direct value 3 from phys reg 2
        issue: Issue INC allocated phys_reg 2

    The key problem is that the physical register is released too early. This physical
    register comes from the RAT. So that RAT entry is still valid, but the physical register the
    RAT is pointing too, is not valid any longer.



- printr has no access to its arch reg

- metrics: instructions issued

- metrics: cycles

- metrics: instructions retired

- metrics: overall ipc

- metrics: ipc last cycle

- store to load forwarding

- verify that store works

- branches

- program termination

- implement print of memory

- implement a proper loader

DONE

- cdb broadcast

- the value of the inc isn't visible when printing

- reverse the ordering of the initial free stack for physical registers

- inc is failing with panic

- register rename of the sink should be done after register rename of the source

- fixed problem in execution due to no proper rs.opcode.

- printr isn't being run

- frontend and trace

- retire isn't picked up

- system runs out of rob-etries; so they are not properly returned.
    - retiring isn't working

- cpu_config issue_n_wide

- cpu config dispatch_n_wide

- implement instruction execution

- implement retire

- instructions should have configurable latency

- an instruction should have only 1 sink

- fix the backend compilation problem

- deal with a full store buffer

- instructions: use asserts instead of panics

- allocate a slot in the store buffer
